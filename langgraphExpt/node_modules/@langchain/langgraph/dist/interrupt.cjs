"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.interrupt = void 0;
const singletons_1 = require("@langchain/core/singletons");
const errors_js_1 = require("./errors.cjs");
const constants_js_1 = require("./constants.cjs");
/**
 * Interrupts the execution of a graph node.
 * This function can be used to pause execution of a node, and return the value of the `resume`
 * input when the graph is re-invoked using `Command`.
 * Multiple interrupts can be called within a single node, and each will be handled sequentially.
 *
 * When an interrupt is called:
 * 1. If there's a `resume` value available (from a previous `Command`), it returns that value.
 * 2. Otherwise, it throws a `GraphInterrupt` with the provided value
 * 3. The graph can be resumed by passing a `Command` with a `resume` value
 *
 * @param value - The value to include in the interrupt. This will be available in task.interrupts[].value
 * @returns The `resume` value provided when the graph is re-invoked with a Command
 *
 * @example
 * ```typescript
 * // Define a node that uses multiple interrupts
 * const nodeWithInterrupts = () => {
 *   // First interrupt - will pause execution and include {value: 1} in task values
 *   const answer1 = interrupt({ value: 1 });
 *
 *   // Second interrupt - only called after first interrupt is resumed
 *   const answer2 = interrupt({ value: 2 });
 *
 *   // Use the resume values
 *   return { myKey: answer1 + " " + answer2 };
 * };
 *
 * // Resume the graph after first interrupt
 * await graph.stream(new Command({ resume: "answer 1" }));
 *
 * // Resume the graph after second interrupt
 * await graph.stream(new Command({ resume: "answer 2" }));
 * // Final result: { myKey: "answer 1 answer 2" }
 * ```
 *
 * @throws {Error} If called outside the context of a graph
 * @throws {GraphInterrupt} When no resume value is available
 */
function interrupt(value) {
    const config = singletons_1.AsyncLocalStorageProviderSingleton.getRunnableConfig();
    if (!config) {
        throw new Error("Called interrupt() outside the context of a graph.");
    }
    // Track interrupt index
    const scratchpad = config.configurable?.[constants_js_1.CONFIG_KEY_SCRATCHPAD];
    if (scratchpad.interruptCounter === undefined) {
        scratchpad.interruptCounter = 0;
    }
    else {
        scratchpad.interruptCounter += 1;
    }
    const idx = scratchpad.interruptCounter;
    // Find previous resume values
    const taskId = config.configurable?.[constants_js_1.CONFIG_KEY_TASK_ID];
    const writes = config.configurable?.[constants_js_1.CONFIG_KEY_WRITES] ?? [];
    if (!scratchpad.resume) {
        const newResume = (writes.find((w) => w[0] === taskId && w[1] === constants_js_1.RESUME)?.[2] || []);
        scratchpad.resume = Array.isArray(newResume) ? newResume : [newResume];
    }
    if (scratchpad.resume) {
        if (idx < scratchpad.resume.length) {
            return scratchpad.resume[idx];
        }
    }
    // Find current resume value
    if (!scratchpad.usedNullResume) {
        scratchpad.usedNullResume = true;
        const sortedWrites = [...writes].sort((a, b) => b[0].localeCompare(a[0]) // Sort in reverse order
        );
        for (const [tid, c, v] of sortedWrites) {
            if (tid === constants_js_1.NULL_TASK_ID && c === constants_js_1.RESUME) {
                if (scratchpad.resume.length !== idx) {
                    throw new Error(`Resume length mismatch: ${scratchpad.resume.length} !== ${idx}`);
                }
                scratchpad.resume.push(v);
                const send = config.configurable?.[constants_js_1.CONFIG_KEY_SEND];
                if (send) {
                    send([[constants_js_1.RESUME, scratchpad.resume]]);
                }
                return v;
            }
        }
    }
    // No resume value found
    throw new errors_js_1.GraphInterrupt([
        {
            value,
            when: "during",
            resumable: true,
            ns: config.configurable?.[constants_js_1.CONFIG_KEY_CHECKPOINT_NS]?.split(constants_js_1.CHECKPOINT_NAMESPACE_SEPARATOR),
        },
    ]);
}
exports.interrupt = interrupt;
